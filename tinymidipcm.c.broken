#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#define TSF_IMPLEMENTATION
#include "tsf.h"

#define TML_IMPLEMENTATION
#include "tml.h"

// TODO customisable
#define SAMPLE_RATE 22050

tml_message *tinymidipcm_render_pcm(tsf *soundfont,
                                    tml_message *midi_message,
                                    uint8_t *pcm_buffer, int samples,
                                    double *msecs) {
    /*tsf *soundfont = tsf_load_memory(soundfont_buffer, soundfont_length);
    tsf_set_output(soundfont, TSF_STEREO_INTERLEAVED, 22050, 0.0f);
    tml_message *midi_message = tml_load_memory(midi_buffer, midi_length);*/

    int bytes_written = 0;

    int block_size = TSF_RENDER_EFFECTSAMPLEBLOCK;

    do {
        *msecs += block_size * (1000.0 / SAMPLE_RATE);

        while (midi_message && *msecs >= midi_message->time) {
            switch (midi_message->type) {
            case TML_PROGRAM_CHANGE:
                tsf_channel_set_presetnumber(soundfont, midi_message->channel,
                                             midi_message->program,
                                             (midi_message->channel == 9));
                break;
            case TML_NOTE_ON:
                tsf_channel_note_on(soundfont, midi_message->channel,
                                    midi_message->key,
                                    midi_message->velocity / 127.0f);
                break;
            case TML_NOTE_OFF:
                tsf_channel_note_off(soundfont, midi_message->channel,
                                     midi_message->key);
                break;
            case TML_PITCH_BEND:
                tsf_channel_set_pitchwheel(soundfont, midi_message->channel,
                                           midi_message->pitch_bend);
                break;
            case TML_CONTROL_CHANGE:
                tsf_channel_midi_control(soundfont, midi_message->channel,
                                         midi_message->control,
                                         midi_message->control_value);
                break;
            }

            midi_message = midi_message->next;
        }

        /*if (bytes_written + (block_size * 4) >= *pcm_length || !midi_message) {
            *pcm_length = bytes_written;
            printf("hmm\n");
            return midi_message;
        }*/

        tsf_render_short(
            soundfont,
            (int16_t *)(pcm_buffer + bytes_written),
            block_size, 0);

        printf("test\n");

        bytes_written += block_size * 4;
    } while (bytes_written < samples);

    return midi_message;
}

int main(int argc, char **argv) {
    int soundfont_length = 3367466;
    FILE *soundfont_file = fopen("./gm.sf2", "r");
    uint8_t *soundfont_buffer = malloc(soundfont_length);
    fread(soundfont_buffer, soundfont_length, 1, soundfont_file);
    fclose(soundfont_file);

    int midi_length = 17704;
    FILE *midi_file = fopen("./runescape-flute salad.mid", "r");
    uint8_t *midi_buffer = malloc(midi_length);
    fread(midi_buffer, midi_length, 1, midi_file);
    fclose(midi_file);

    tsf *soundfont = tsf_load_memory(soundfont_buffer, soundfont_length);
    tsf_set_output(soundfont, TSF_STEREO_INTERLEAVED, 22050, 0.0f);

    tml_message *midi_message = tml_load_memory(midi_buffer, midi_length);

    double msecs = 0;
    int samples = TSF_RENDER_EFFECTSAMPLEBLOCK * 10;
    uint8_t pcm_buffer[TSF_RENDER_EFFECTSAMPLEBLOCK * 10 * 2] = {0};

    FILE *test = fopen("./out.pcm", "a+");

    do {

        printf("---\n");
        midi_message = tinymidipcm_render_pcm(soundfont, midi_message,
                                              pcm_buffer, samples, &msecs);
        printf("---\n");

        fwrite(pcm_buffer, samples * 2, 1, test);
    } while (midi_message != NULL);

    //printf("%d %d\n", last_message, pcm_length);
}
